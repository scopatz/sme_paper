\documentclass[preprint,12pt]{elsarticle}

%General Short-Cut Commands
\newcommand{\superscript}[1]{\ensuremath{^{\textrm{#1}}}}
\newcommand{\subscript}[1]{\ensuremath{_{\textrm{#1}}}}
\newcommand{\nuc}[2]{\superscript{#2}{#1}}
\newcommand{\ith}[0]{$i$\superscript{th}}
\newcommand{\jth}[0]{$j$\superscript{th}}
\newcommand{\kth}[0]{$k$\superscript{th}}

\usepackage{natbib}
%\bibpunct[,]{[}{]}{;}{a}{,}{,}
\bibliographystyle{model2-names}

% Needed for making certian figures
\usepackage{color}
\usepackage{tikz}
\usepackage{verbatim}
\usetikzlibrary{shapes,arrows}

\journal{Some Separations Journal}

% Start this document...
\begin{document}

% Article commands
\begin{frontmatter}
\title{Symbolic Multicomponent Enrichment for Matched Abundance Ratio Cascades}

\author[chi]{Anthony M. Scopatz\corref{cor1}}
\ead{scopatz@flash.uchicago.edu}
\cortext[cor1]{Corresponding author}

\address[chi]{The University of Chicago, The FLASH Center, 
              5754 S. Ellis Ave, Chicago, IL, 60637}


% Text of abstract
\begin{abstract}
Some abstract text
\end{abstract}

%% keywords here, in the form: keyword \sep keyword
\begin{keyword}
%% MSC codes here, in the form: \MSC code \sep code
%% or \MSC[2008] code \sep code (2000 is the default)
\end{keyword}

\end{frontmatter}


%
% Begin real text
%

\section{Introduction}
\label{sec:intro}
Symbolic evaluation is slow, except...


\section{Symbolic Methodology}
\label{sec:meth}
At its core, the solution to coupled multicomponent enrichment cascade equations is
a minimization problem \cite{Wood1999}.  In a matched abundance ratio 
\cite{DelaGarza1969} cascade this is often cast as the minimization of 
the total flow rate $L_t$ through the system normalized by the feed flow rate $F$ to 
form the positive and unitless optimization variable $L_t/F$.  Traditionally, 
minimizing this parameter as a function of other cascade state variables has been 
performed eiether via off-the-shelf optimization libraries 
\cite{doi:10.1080/01496391003793884} or custom built solvers CITEpyne.

However, both of these approaches rely on writing code idiomatic to underlying 
programming language.  For example, many numerical constraint optimizers, in order 
to handle the case of arbiratily complex expressions, accept as their primary 
argument a function object or pointer.  Then for every iteration the optimizer must 
call the function to be optimized.  This involves (in compiled languages) setting up 
a new stack and allocating new memory for every solver iteration.  While good 
optimizers will be effieicnt in terms of the number of function calls they make, 
there is no way for them to avoid multiple function calls and remain sufficiently 
general. The number of function calls that are needed scales \emph{at least} linearly 
with the number of equations in the system.

On the other hand, if it is possible to convert the system of equations 
into a single expression -- no matter how complicated -- then the problem has been 
recast into the optimization of a single fucntion over a single variable.   This 
may be easily handed off to any number of well known algorithims, such as Newton's
method, the secant method, or the bisection method.  In such a form, the solution 
will have a vastly reduced computational overhead as compared to standard 
numerical solvers. 

Naturally, performing the above variable substitution and elimination to obtain a 
single expression is difficult in many cases and mathematically impossible in most 
others.  For MARC systems, as is shown in \S \ref{sec:symes}, reduction of $L_t/F$
to a single expression is possible.

Rather than phrasing this as a numerical optimization problem from the start, the 
opposite conceptual tactic is taken.  The MARC system is expandend, manipulated, 
and subsititued symbolically the the majority of the calculation.  The actual 
numerical results of the calculation are only computed as needed as the final step.
The symbolic manipulation is generated prior to compilation, resulting in 
very fast run time solutions.

In \S \ref{sec:marceq} the standard MARC system of equations is detailed. Then \S 
\ref{sec:codegen} characterizes the pipeline that takes the symbolic MARC eqautions 
and converts them into machine code.  The novel reinterpretation of the MARC equations
is related in \S \ref{sec:symes}.  For the remainder of \S \ref{sec:meth}, a
three-component natural uranium fed cascade will be used when example data is required.
Higher order cascades will be displayed in \S \ref{sec:res}.

\subsection{MARC Equations}
\label{sec:marceq}

Call $N$ the total number of stages in an enrichment cascade, $N_P$ the number of 
product (enriching) stages above the feed entry, and $N_T$ the number of tails
(stripping) stages below the feed point such that:
\begin{equation}
N = N_P + N_T
\end{equation}
Furthermore, MARC requires that we declare a species to enrich in the 
product (subscript P).  This is known as the first key component an is denoted 
here as $j$.  There must also be a second key component $k$ from which $j$ is 
separated. Thus $k$ is more abundant in the tails stream (subscript T).

The ovearll stage separation factor $\alpha$ [unitless] represents the per mass 
enrichment ratio from one stage to the next.  This yeilds component-specific
stage separation factors $\beta_i$ for the \ith component of a mixture $I$:
\begin{equation}
\beta_i = \alpha^{M^* - M_i}
\label{beta_i}
\end{equation}
Here, $M_i$ represents the molecular weight [amu] of the \ith
species while $M^*$ [amu] is an optimization parameter.  An initial first guess for 
$M^*$ is given by the average of the molecular weights of the key components:
\begin{equation}
M^* = \frac{1}{2}\left(M_j + M_k\right)
\end{equation}
By convention, $j$ \& $k$ are chosen such that $M_j < M_k$ and 
therefore $M^*$ is bounded on the range $M^*\in[M_j,M_k]$ when minimizing $L_t/F$.

Let $F$, $P$, and $T$ be the feed, product, and tails mass flow rates subject to 
the conservation equation:
\begin{equation}
F = P + T
\label{total-flow-constraint}
\end{equation}
Also let $x$ denote a normalized mass concentration vector such that $x_i^F$, 
$x_i^P$, $x_i^T$ are the concetrations of the \ith component of the feed, product,
and tails respectively.  Thus:
\begin{equation}
1 = \sum_i^I x_i^F = \sum_i^I x_i^P = \sum_i^I x_i^T 
\end{equation}
Therefore the flow rate ratios are:
\begin{equation}
\frac{P}{F} = \sum_i^I x_i^F\frac{\beta_i^{N_T+1} - 1}
                                 {\beta_i^{N_T+1} - \beta_i^{-N_P}}
\label{ppf-full}
\end{equation}
\begin{equation}
\frac{T}{F} = \sum_i^I x_i^F\frac{1 - \beta_i^{-N_P}}
                                 {\beta_i^{N_T+1} - \beta_i^{-N_P}}
\label{tpf-full}
\end{equation}
Equations \ref{ppf-full} \&  \ref{tpf-full} can be further reduced to functions
of just the first key component:
\begin{equation}
\frac{P}{F} = \frac{x_j^F - x_j^T}{x_j^P - x_j^T}
\label{ppf-key}
\end{equation}
\begin{equation}
\frac{T}{F} = \frac{x_j^F - x_j^P}{x_j^T - x_j^P}
\label{tpf-key}
\end{equation}

Either equations \ref{ppf-full} \& \ref{tpf-full} or equations \ref{ppf-key} \& 
\ref{tpf-key} allow the calculation of the \ith component concentrations of in the 
product and tails streams as a function of the feed concentrations.
\begin{equation}
x_i^P = \frac{x_i^F}{\frac{P}{F}}\cdot\frac{\beta_i^{N_T+1} - 1}
                                           {\beta_i^{N_T+1} - \beta_i^{-N_P}}
\end{equation}
\begin{equation}
x_i^T = \frac{x_i^F}{\frac{T}{F}}\cdot\frac{1 - \beta_i^{-N_P}}
                                           {\beta_i^{N_T+1} - \beta_i^{-N_P}}
\end{equation}
By analogy to equation \ref{total-flow-constraint}, the components themselves are
also subject to mass conservation:
\begin{equation}
x_i^FF = x_i^PP + x_i^TT
\label{comp-flow-constraint}
\end{equation}


\subsection{Code Generation Pipeline}
\label{sec:codegen}

\subsection{Symbolic Enrichment Solver}
\label{sec:symes}

\section{Results \& Profiling}
\label{sec:res}

\section{Conclusions \& Future Work}
\label{sec:conc}

\bibliography{refs}

\end{document}
