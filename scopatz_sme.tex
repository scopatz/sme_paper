\documentclass[preprint,12pt]{elsarticle}

%General Short-Cut Commands
\newcommand{\superscript}[1]{\ensuremath{^{\textrm{#1}}}}
\newcommand{\subscript}[1]{\ensuremath{_{\textrm{#1}}}}
\newcommand{\nuc}[2]{\superscript{#2}{#1}}

\usepackage{natbib}
%\bibpunct[,]{[}{]}{;}{a}{,}{,}
\bibliographystyle{model2-names}

% Needed for making certian figures
\usepackage{color}
\usepackage{tikz}
\usepackage{verbatim}
\usetikzlibrary{shapes,arrows}

\journal{Some Separations Journal}

% Start this document...
\begin{document}

% Article commands
\begin{frontmatter}
\title{Symbolic Multicomponent Enrichment for Matched Abundance Ratio Cascades}

\author[chi]{Anthony M. Scopatz\corref{cor1}}
\ead{scopatz@flash.uchicago.edu}
\cortext[cor1]{Corresponding author}

\address[chi]{The University of Chicago, The FLASH Center, 
              5754 S. Ellis Ave, Chicago, IL, 60637}


% Text of abstract
\begin{abstract}
Some abstract text
\end{abstract}

%% keywords here, in the form: keyword \sep keyword
\begin{keyword}
%% MSC codes here, in the form: \MSC code \sep code
%% or \MSC[2008] code \sep code (2000 is the default)
\end{keyword}

\end{frontmatter}


%
% Begin real text
%

\section{Introduction}
\label{sec:intro}
Symbolic evaluation is slow, except...


\section{Symbolic Methodology}
\label{sec:meth}
At its core, the solution to coupled multicomponent enrichment cascade equations is
a minimization problem \cite{Wood1999}.  In a matched abundance ratio 
\cite{DelaGarza1969} cascade this is often cast as the minimization of 
the total flow rate $L_t$ through the system normalized by the feed flow rate $F$ to 
form the positive and unitless optimization variable $L_t/F$.  Traditionally, 
minimizing this parameter as a function of other cascade state variables has been 
performed eiether via off-the-shelf optimization libraries 
\cite{doi:10.1080/01496391003793884} or custom built solvers CITEpyne.

However, both of these approaches rely on writing code idiomatic to underlying 
programming language.  For example, many numerical constraint optimizers, in order 
to handle the case of arbiratily complex expressions, accept as their primary 
argument a function object or pointer.  Then for every iteration the optimizer must 
call the function to be optimized.  This involves (in compiled languages) setting up 
a new stack and allocating new memory for every solver iteration.  While good 
optimizers will be effieicnt in terms of the number of function calls they make, 
there is no way for them to avoid multiple function calls and remain sufficiently 
general. The number of function calls that are needed scales \emph{at least} linearly 
with the number of equations in the system.

On the other hand, if it is possible to convert the system of equations 
into a single expression -- no matter how complicated -- then the problem has been 
recast into the optimization of a single fucntion over a single variable.   This 
may be easily handed off to any number of well known algorithims, such as Newton's
method, the secant method, or the bisection method.  In such a form, the solution 
will have a vastly reduced computational overhead as compared to standard 
numerical solvers. 

Naturally, performing the above variable substitution and elimination to obtain a 
single expression is difficult in many cases and mathematically impossible in most 
others.  For MARC systems, as is shown in \S \ref{sec:symes}, reduction of $L_t/F$
to a single expression is possible.

Rather than phrasing this as a numerical optimization problem from the start, the 
opposite conceptual tactic is taken.  The MARC system is expandend, manipulated, 
and subsititued symbolically the the majority of the calculation.  The actual 
numerical results of the calculation are only computed as needed as the final step.
The symbolic manipulation is generated prior to compilation, resulting in 
very fast run time solutions.

In \S \ref{sec:marceq} the standard MARC system of equations is detailed. Then \S 
\ref{sec:codegen} characterizes the pipeline that takes the symbolic MARC eqautions 
and converts them into machine code.  The novel reinterpretation of the MARC equations
is related in \S \ref{sec:symes}.  For the remainder of \S \ref{sec:meth}, a
three-component natural uranium fed cascade will be used when example data is required.
Higher order cascades will be displayed in \S \ref{sec:res}.

\subsection{MARC Equations}
\label{sec:marceq}

\subsection{Code Generation Pipeline}
\label{sec:codegen}

\subsection{Symbolic Enrichment Solver}
\label{sec:symes}

\section{Results \& Profiling}
\label{sec:res}

\section{Conclusions \& Future Work}
\label{sec:conc}

\bibliography{refs}

\end{document}
